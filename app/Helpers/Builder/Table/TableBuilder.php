<?php

namespace App\Helpers\Builder\Table;

use App\Enums\ColumnTypeEnum;
use App\Helpers\Builder\Table\Features\Columns;
use App\Helpers\Builder\Table\Features\Exportable;
use App\Helpers\Builder\Table\Features\Orderable;
use App\Helpers\Builder\Table\Features\Paginable;
use App\Helpers\Builder\Table\Features\Searchable;
use App\Helpers\Builder\Table\Features\Sortable;
use App\Helpers\Builder\Table\Features\Terminal;
use App\Models\Outputs\Recipient;
use ArrayAccess;
use Closure;
use Illuminate\Database\Eloquent\Builder as EloquentBuilder;
use Illuminate\Database\Query\Builder as QueryBuilder;
use Illuminate\Http\Request;
use Illuminate\Pagination\Paginator;
use Illuminate\View\View;

class TableBuilder
{
    use Searchable;
    use Sortable;
    use Exportable;
    use Paginable;
    use Orderable;
    use Columns;
    use Terminal;

    private string $identifier;
    private string $row_identifier = "";
    private ArrayAccess $lines;
    private Request $request;
    private EloquentBuilder|QueryBuilder $query;

    public function __construct(string $identifier, Request $request)
    {
        $this->identifier = $identifier;
        $this->request    = $request;

        // keep GET params from url without current pagination (generated by the render)
        Paginator::currentPathResolver(Closure::fromCallable([$this, 'setPaginationUrl']));
    }

    public function getIdentifier(): string
    {
        return $this->identifier;
    }

    public function getRequest(): Request
    {
        return $this->request;
    }

    public function getLines(): ArrayAccess
    {
        return $this->lines;
    }

    public function setRowIdentifier(string $row_identifier): self
    {
        $this->row_identifier = $row_identifier;
        return $this;
    }

    public function getRowIdentifier(): ?string
    {
        return $this->row_identifier;
    }

    public function setQuery(EloquentBuilder|QueryBuilder $query): self
    {
        $this->query = $query;
        $this->setSearchOptions($this->request);
        $this->setOrderBy($this->request);
        $this->executeQuery();
        return $this;
    }

    private function executeQuery(): self
    {
        $query = $this->query;
        $options = $this->search_options;

        foreach ($this->columns as $column) {
            $key = $column->getKey();
            $where_key = $column->getWhereKey();
            $search_key = $where_key ?: $key;

            if (isset($options[$key]) && $options[$key] !== "") {
                switch ($column->getType()) {
                    case ColumnTypeEnum::FULLTEXT:
                        $term = implode("* ", explode(" ", $options[$key])) . "*";
                        $query->whereRaw(sprintf("MATCH(%s) AGAINST('%s' IN BOOLEAN MODE)", $search_key, $term));
                        break;
                    case ColumnTypeEnum::TEXT:
                        $query->where($search_key, 'like', '%' . $options[$key] . '%');
                        break;
                    case ColumnTypeEnum::BOOLEAN:
                        $value = !is_null($options[$key]) ? boolval($options[$key]) : null;
                        $query->where($search_key, $value);
                        break;
                    case ColumnTypeEnum::NUMBER:
                    case ColumnTypeEnum::PRICE:
                    case ColumnTypeEnum::PERCENTAGE:
                    default:
                        $query->where($search_key, $options[$key]);
                        break;
                }
            }

            if ((isset($options[$key . '_from']) || isset($options[$key . '_to'])) && (($options[$key . '_from'] !== '' || $options[$key . '_to'] !== ''))) {
                $key_from = $key . '_from';
                $key_to = $key . '_to';
                $query
                    ->whereDate($search_key, '>=', $options[$key_from])
                    ->whereDate($search_key, '<=', $options[$key_to]);
            }
        }

        if ($this->order_by && $this->order_way) {
            $query->getQuery()->orders = null;
            $query->orderBy($this->order_by, $this->order_way);
        }

        $this->lines = $this->isPaginable() ? $query->paginate($this->getPerPage(), ['*'], 'page_' . $this->identifier) : $query->get();
        return $this;
    }

    // --------------------------------------------------------------
    // Rendering methods :
    // @TODO : move to a TableRenderer or abstract controller class ?
    // --------------------------------------------------------------
    public function render(): View
    {
        $template = $this->is_for_terminal ? 'helpers/table/terminal_table' : 'helpers/table/table';
        return view($template)->with('table', $this);
    }

    public function getLinesCountBadge(): string
    {
        $total = $this->isPaginable() ? $this->getLines()->total() : $this->getLines()->count();
        return '<span class="badge bg-primary">' . $total . '</span>';
    }

    private function setPaginationUrl(): string
    {
        return (is_null($this->request->query->get('page_' . $this->identifier)))
            ? $this->request->getUri()
            : $this->request->url() . $this->regenerateQueryWithoutCurrentPagination();
    }

    private function regenerateQueryWithoutCurrentPagination() : string
    {
        // remove current pagination from queries
        $new_queries = array_filter($this->request->query->all(), function ($item) {
            return $item !== 'page_' . $this->identifier;
        }, ARRAY_FILTER_USE_KEY);

        // generate query url (?$key=value&$key=value...)
        return (count($new_queries) > 0) ? '?' . http_build_query($new_queries) : '';
    }
}
